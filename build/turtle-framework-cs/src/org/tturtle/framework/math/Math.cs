// Generated by Haxe 4.3.4

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace org.tturtle.framework.math {
	public class Math : global::haxe.lang.HxObject {
		
		static Math() {
			global::org.tturtle.framework.math.Math.PI = 3.14159265358979323846;
		}
		
		
		public Math(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Math() {
			global::org.tturtle.framework.math.Math.__hx_ctor_org_tturtle_framework_math_Math(this);
		}
		
		
		protected static void __hx_ctor_org_tturtle_framework_math_Math(global::org.tturtle.framework.math.Math __hx_this) {
		}
		
		
		public static double PI;
		
		public static double @add(params double[] numbers) {
			double result = ((double) (0) );
			{
				int _g_current = 0;
				while (( _g_current < ( ((double[]) (numbers) ) as global::System.Array ).Length )) {
					result += ((double[]) (numbers) )[_g_current++];
				}
				
			}
			
			return result;
		}
		
		
		public static double subtract(params double[] numbers) {
			double result = ((double) (0) );
			bool firstNum = true;
			{
				int _g_current = 0;
				while (( _g_current < ( ((double[]) (numbers) ) as global::System.Array ).Length )) {
					double number = ((double[]) (numbers) )[_g_current++];
					if (firstNum) {
						result = number;
						firstNum = false;
						continue;
					}
					
					result -= number;
				}
				
			}
			
			return result;
		}
		
		
		public static double multiply(params double[] numbers) {
			double result = ((double) (0) );
			bool firstNum = true;
			{
				int _g_current = 0;
				while (( _g_current < ( ((double[]) (numbers) ) as global::System.Array ).Length )) {
					double number = ((double[]) (numbers) )[_g_current++];
					if (firstNum) {
						result = number;
						firstNum = false;
						continue;
					}
					
					result *= number;
				}
				
			}
			
			return result;
		}
		
		
		public static double divide(params double[] numbers) {
			double result = ((double) (0) );
			bool firstNum = true;
			{
				int _g_current = 0;
				while (( _g_current < ( ((double[]) (numbers) ) as global::System.Array ).Length )) {
					double number = ((double[]) (numbers) )[_g_current++];
					if (firstNum) {
						result = number;
						firstNum = false;
						continue;
					}
					
					result /= number;
				}
				
			}
			
			return result;
		}
		
		
		public static double pow(double number, int power) {
			unchecked {
				double starterNumber = number;
				{
					int _g = 0;
					int _g1 = ( power - 1 );
					while (( _g < _g1 )) {
						 ++ _g;
						number *= starterNumber;
					}
					
				}
				
				return number;
			}
		}
		
		
		public static double abs(double number) {
			if (( number < 0 )) {
				return  - (number) ;
			}
			else {
				return number;
			}
			
		}
		
		
		public virtual double sin(double x) {
			unchecked {
				double result = ((double) (0) );
				double term = x;
				double sign = ((double) (-1) );
				double power = x;
				double factorial = ((double) (1) );
				{
					int _g = 1;
					while (( _g < 10 )) {
						int i = _g++;
						result += ( sign * term );
						power *= ( x * x );
						factorial *= ((double) (( ( 2 * i ) * (( ( 2 * i ) + 1 )) )) );
						term *= ( power / factorial );
						sign *= ((double) (-1) );
					}
					
				}
				
				return result;
			}
		}
		
		
		public virtual double tan(double x) {
			unchecked {
				double result = ((double) (0) );
				double term = x;
				double sign = ((double) (1) );
				double prevResult = ((double) (0) );
				{
					int _g = 1;
					while (( _g < 100 )) {
						result += ( sign * term );
						sign *= ((double) (1) );
						term *= ( ( x * x ) / (( ( 2 * _g++ ) + 1 )) );
						if (( global::org.tturtle.framework.math.Math.abs(( result - prevResult )) < 0.000001 )) {
							break;
						}
						
						prevResult = result;
					}
					
				}
				
				return result;
			}
		}
		
		
		public virtual double sqrt(double x) {
			unchecked {
				if (( x <= 0 )) {
					return ((double) (0) );
				}
				
				double guess = ( x / 2 );
				double prevGuess = default(double);
				do {
					prevGuess = guess;
					guess = ( (( guess + ( x / guess ) )) / 2 );
				}
				while ( ! ((( global::org.tturtle.framework.math.Math.abs(( guess - prevGuess )) < 0.00001 ))) );
				return guess;
			}
		}
		
		
		public virtual int round(double x) {
			return ((int) (( x + 0.5 )) );
		}
		
		
		public virtual double random() {
			unchecked {
				global::Date _this = new global::Date(((global::System.DateTime) (global::System.DateTime.Now) ));
				double seed = ( ((double) (((long) (( ((long) (global::System.TimeZone.CurrentTimeZone.ToUniversalTime(((global::System.DateTime) (_this.date) )).Ticks) ) - ((long) (global::Date.epochTicks) ) )) )) ) / ((double) (global::System.TimeSpan.TicksPerMillisecond) ) );
				seed = ((double) (( ( ( ((int) (seed) ) * 1103515245 ) + 12345 ) & 2147483647 )) );
				return ( seed / 2147483647 );
			}
		}
		
		
		public virtual double min(double a, double b) {
			if (( a > b )) {
				return a;
			}
			else {
				return b;
			}
			
		}
		
		
		public override object __hx_getField(string field, int hash, bool throwErrors, bool isCheck, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 5443986:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "min", 5443986)) );
					}
					
					
					case 932127235:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "random", 932127235)) );
					}
					
					
					case 1835399246:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "round", 1835399246)) );
					}
					
					
					case 1280945120:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "sqrt", 1280945120)) );
					}
					
					
					case 5790305:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "tan", 5790305)) );
					}
					
					
					case 5742360:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "sin", 5742360)) );
					}
					
					
					default:
					{
						return base.__hx_getField(field, hash, throwErrors, isCheck, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_invokeField(string field, int hash, object[] dynargs) {
			unchecked {
				switch (hash) {
					case 5443986:
					{
						return this.min(((double) (global::haxe.lang.Runtime.toDouble(dynargs[0])) ), ((double) (global::haxe.lang.Runtime.toDouble(dynargs[1])) ));
					}
					
					
					case 932127235:
					{
						return this.random();
					}
					
					
					case 1835399246:
					{
						return this.round(((double) (global::haxe.lang.Runtime.toDouble(dynargs[0])) ));
					}
					
					
					case 1280945120:
					{
						return this.sqrt(((double) (global::haxe.lang.Runtime.toDouble(dynargs[0])) ));
					}
					
					
					case 5790305:
					{
						return this.tan(((double) (global::haxe.lang.Runtime.toDouble(dynargs[0])) ));
					}
					
					
					case 5742360:
					{
						return this.sin(((double) (global::haxe.lang.Runtime.toDouble(dynargs[0])) ));
					}
					
					
					default:
					{
						return base.__hx_invokeField(field, hash, dynargs);
					}
					
				}
				
			}
		}
		
		
	}
}


